import {
	cleanupOutdatedCaches,
	createHandlerBoundToURL,
	precacheAndRoute
} from 'workbox-precaching';
import { NavigationRoute, registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';

// Extend ServiceWorkerGlobalScope with needed types
interface ExtendedServiceWorkerGlobalScope extends ServiceWorkerGlobalScope {
	__WB_MANIFEST: unknown;
}

interface SyncEvent extends ExtendableEvent {
	tag: string;
}

interface PushEvent extends ExtendableEvent {
	data?: {
		text(): string;
	};
}

interface NotificationEvent extends ExtendableEvent {
	notification: Notification;
	action?: string;
}

declare let self: ExtendedServiceWorkerGlobalScope;

// Clean up old caches
cleanupOutdatedCaches();

// Precache all the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing for SPA
const handler = createHandlerBoundToURL('/');
const navigationRoute = new NavigationRoute(handler, {
	denylist: [/^\/_app\//, /^\/api\//]
});
registerRoute(navigationRoute);

// Cache API responses for offline browsing
registerRoute(
	({ url }) => url.pathname.startsWith('/api/chat/generate-title'),
	new NetworkFirst({
		cacheName: 'api-cache',
		networkTimeoutSeconds: 10
	})
);

// Cache static assets
registerRoute(
	({ request }) => request.destination === 'style',
	new CacheFirst({
		cacheName: 'styles-cache',
		plugins: [
			{
				cacheKeyWillBeUsed: async ({ request }) => {
					return `${request.url}?v=${Date.now()}`;
				}
			}
		]
	})
);

// Cache images
registerRoute(
	({ request }) => request.destination === 'image',
	new CacheFirst({
		cacheName: 'images-cache',
		plugins: [
			{
				cacheKeyWillBeUsed: async ({ request }) => {
					return `${request.url}?v=${Date.now()}`;
				}
			}
		]
	})
);

// Cache scripts
registerRoute(
	({ request }) => request.destination === 'script',
	new StaleWhileRevalidate({
		cacheName: 'scripts-cache',
		plugins: [
			{
				cacheKeyWillBeUsed: async ({ request }) => {
					return `${request.url}?v=${Date.now()}`;
				}
			}
		]
	})
);

// Cache fonts
registerRoute(
	({ request }) => request.destination === 'font',
	new CacheFirst({
		cacheName: 'fonts-cache',
		plugins: [
			{
				cacheKeyWillBeUsed: async ({ request }) => {
					return `${request.url}?v=${Date.now()}`;
				}
			}
		]
	})
);

// Handle background sync for offline message sending
self.addEventListener('sync', (event: Event) => {
	const syncEvent = event as SyncEvent;
	if (syncEvent.tag === 'send-message') {
		syncEvent.waitUntil(sendQueuedMessages());
	}
});

async function sendQueuedMessages() {
	try {
		// Get queued messages from IndexedDB
		const db = await openDB();
		const tx = db.transaction(['offlineQueue'], 'readonly');
		const store = tx.objectStore('offlineQueue');
		const queuedMessages = await getAllFromStore(store);

		console.log(`Found ${queuedMessages.length} queued messages to send`);

		// Process each queued message
		for (const item of queuedMessages) {
			try {
				// Attempt to send the message
				const response = await fetch('/api/chat', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(item.data)
				});

				if (response.ok) {
					// Remove from queue on success
					const deleteTx = db.transaction(['offlineQueue'], 'readwrite');
					await deleteTx.objectStore('offlineQueue').delete(item.id);
					console.log('Successfully sent queued message:', item.id);
				}
			} catch (error) {
				console.error('Failed to send queued message:', item.id, error);
			}
		}
	} catch (error) {
		console.error('Error processing queued messages:', error);
	}
}

// Helper function to get all items from an object store
function getAllFromStore(store: IDBObjectStore): Promise<unknown[]> {
	return new Promise((resolve, reject) => {
		const request = store.getAll();
		request.onsuccess = () => resolve(request.result);
		request.onerror = () => reject(request.error);
	});
}

// Helper function to open IndexedDB
async function openDB(): Promise<IDBDatabase> {
	return new Promise((resolve, reject) => {
		const request = indexedDB.open('chatApp', 1);

		request.onerror = () => reject(request.error);
		request.onsuccess = () => resolve(request.result);

		request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
			const db = (event.target as IDBOpenDBRequest).result;
			if (!db.objectStoreNames.contains('offlineQueue')) {
				db.createObjectStore('offlineQueue', { keyPath: 'id' });
			}
		};
	});
}

// Handle push notifications (future enhancement)
self.addEventListener('push', (event: Event) => {
	const pushEvent = event as PushEvent;
	const options = {
		body: pushEvent.data?.text() || 'New message available',
		icon: '/icon-192.png',
		badge: '/favicon.png',
		tag: 'ai-chat-notification',
		requireInteraction: false,
		actions: [
			{
				action: 'open',
				title: 'Open Chat'
			},
			{
				action: 'dismiss',
				title: 'Dismiss'
			}
		]
	};

	pushEvent.waitUntil(self.registration.showNotification('AI Tool Chat', options));
});

// Handle notification clicks
self.addEventListener('notificationclick', (event: Event) => {
	const notificationEvent = event as NotificationEvent;
	notificationEvent.notification.close();

	if (notificationEvent.action === 'open' || !notificationEvent.action) {
		notificationEvent.waitUntil(self.clients.openWindow('/'));
	}
});

// Network connectivity detection
self.addEventListener('online', () => {
	console.log('Back online');
});

self.addEventListener('offline', () => {
	console.log('Gone offline');
});
